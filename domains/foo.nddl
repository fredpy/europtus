/*********************************************************************
 * Software License Agreement (BSD License)
 * 
 *  Copyright (c) 2015, Frederic Py.
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of the TREX Project nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 * 
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
#include "Plasma.nddl"

float TICK_DURATION; // duration of a tick in seconds (determined by europtus)
int   CUR_DATE, FINAL_TICK; // update as the tick is advancing in real-time (by europtus)
                     	    //   its value should remain [cur-tick, +inf)
                     	    //  and it shoud be only used to compare against other time points


class Position extends Timeline {

  predicate at {
    float latitude, longitude;
  }

  Position() {
    super();
  }
}

class AUV_plan {
  float source_lat, source_lon;
  float dest_lat, dest_lon;
  float distance;

  AUV_plan(float src_lat, float src_lon,
	   float end_lat, float end_lon,
	   float length) {
    source_lat = src_lat;
    source_lon = src_lon;
    dest_lat = end_lat;
    dest_lon = end_lon;
    distance = length;
  }
}

class AUV extends Timeline {
  Position pos;
  float max_speed;

  action move {
    start<=FINAL_TICK; 
    float speed;
    float distance;
  }

  action doSurvey {
    start<=FINAL_TICK; 
    float speed;
    AUV_plan survey;
  }

  AUV() {
    super();
    pos = new Position();
    max_speed = 1.75;
  }
}

AUV::move {
  Position my_pos;
  my_pos == object.pos;
  distance >= 0.0;
  speed >= 0.2;
  speed <= object.max_speed;
  
  meets(effect my_pos.at destination);
  starts_during(condition my_pos.at source);

  float duration_sec, duration_f;

  temporalDistance(start, duration, end);
  ceil(duration_f) == duration;
  duration_sec == duration_f * TICK_DURATION;
  

  // TODO put some constraints to compute the distance and navigation time
  distance <= duration_sec * speed;
  
}

AUV::doSurvey {
  Position my_pos;
  my_pos == object.pos;
  speed >= 0.2;
  speed <= object.max_speed;
  
  meets(effect my_pos.at destination);
  starts_during(condition my_pos.at source);

  destination.latitude == survey.dest_lat;
  destination.longitude == survey.dest_lon;
  source.latitude == survey.source_lat;
  source.longitude == survey.source_lon;

  float duration_sec, duration_f;

  temporalDistance(start,duration,end); 

  ceil(duration_f) == duration;
  duration_sec == duration_f * TICK_DURATION;

  survey.distance >= 0.;
  survey.distance <= duration_sec * speed;
}

AUV xtreme1 = new AUV();

fact(xtreme1.pos.at initial);

initial.start    = 0;
initial.latitude = 12.5;
initial.longitude = 32.6;

rejectable(xtreme1.pos.at dest);

0 <= dest.start;
dest.start <= FINAL_TICK;
dest.latitude = 12.8;
dest.longitude = 32.5;
